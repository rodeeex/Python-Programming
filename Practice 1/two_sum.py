# Помню данную задачу, она была на LeetCode. Полученное решение даёт нам временную сложность O(n).
# Вероятность очень мала, но может быть и O(n^2).
"""
Алгоритм:
1) Заводим словарь с посещёнными элементами (где значение - это индекс в массиве)
2) Пропускаем значения, которые не являются числами
3) Вычисляем разность между искомой суммой и текущим элементом
4) Если эта разность уже есть в словаре, то проверяем пару из неё и текущего значения на "минимальность".
Элементы, кстати, заранее выставляем именно в порядке "посещённый-текущий",
так как индекс первого будет в любом случае меньше второго.
5) Добавляем текущий элемент в посещённые, если ещё отсутствует
(допустим возникнет ситуация, что в массиве дубликаты, тогда индекс возьмётся все равно наименьший)
6) Возвращаем минимальную пару индексов. Если её нет вообще, то вернётся None.

Примечание: все нецелочисленные элементы пропускаются
"""


def two_sum(nums, target):
    is_integer = lambda x: isinstance(x, int)

    seen_elements = dict()
    min_indices = None

    for idx, num in enumerate(nums):
        if not is_integer(num):
            continue

        diff = target - num
        if diff in seen_elements:
            current_pair = seen_elements[diff], idx
            if min_indices is None or current_pair < min_indices:
                min_indices = current_pair

        if num not in seen_elements:
            seen_elements[num] = idx

    return min_indices
